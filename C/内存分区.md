## 1. 数据类型

### 1.1. 数据类型概念
什么是数据类型？为什么需要数据类型?
数据类型是为了更好进行内存的管理,让编译器能确定分配多少内存。

**数据类型基本概念：**
1.  类型是对数据的抽象;
2.  类型相同的数据具有相同的表示形式、存储格式以及相关操作;
3.  程序中所有的数据都必定属于某种数据类型;
4.  数据类型可以理解为创建变量的模具: **固定大小内存的别名**;
![[image/Pasted image 20230418110103.png|600]]
### 1.2. 数据类型别名 typedef
```cpp
typedef unsigned int u32;
typedef struct _PERSON{
	char name[64];
	int age;
}Person;

void test(){
	u32 val; //相当于 unsigned int val;
	Person person; //相当于 struct PERSON person;
}
```
### 1.3. void 数据类型
void字面意思是”无类型”, `void*` 无类型指针，无类型指针可以指向任何类型的数据。
void定义变量是没有任何意义的，当你定义`void a`，**编译器会报错**。

**void真正用在以下两个方面：**
1.  对函数返回的限定；
2.  对函数参数的限定；
```cpp
// 1. void修饰函数参数和函数返回
void test01(void){
	printf("hello world");
}

// 2. 不能定义void类型变量
void test02(){
	void val; //报错
}

// 3. void* 可以指向任何类型的数据，被称为万能指针
void test03(){
	int a = 10;
	void* p = NULL;
	p = &a;
	printf("a:%d\n",*(int*)p);
	
	char c = 'a';
	p = &c;
	printf("c:%c\n",*(char*)p);
}

//4. void* 常用于数据类型的封装
void test04(){
	//void * memcpy(void * _Dst, const void * _Src, size_t _Size);
}
```

### 1.4. sizeof操作符
sizeof是c语言中的一个操作符，类似于++、--等等。sizeof能够告诉我们编译器为某一特定数据或者某一个类型的数据在内存中分配空间时分配的大小，大小以字节为单位。

**基本语法：**
1.  sizeof(变量)
2.  sizeof 变量
3.  sizeof(类型)

**sizeof 注意点：**
1.  sizeof返回的占用空间大小是为这个变量开辟的大小，而不只是它用到的空间。和现今住房的建筑面积和实用面积的概念差不多。所以对结构体用的时候，大多情况下就得考虑**字节对齐**的问题了；
2.  sizeof返回的数据结果类型是unsigned int；
3.  要注意数组名和指针变量的区别。通常情况下，我们总觉得数组名和指针变量差不多，但是在用sizeof的时候差别很大，**对数组名用sizeof返回的是整个数组的大小，而对指针变量进行操作的时候返回的则是指针变量本身所占得空间**，在32位机的条件下一般都是4。而且当数组名作为函数参数时，在函数内部，形参也就是个指针，所以不再返回数组的大小；
```cpp
//1. sizeof基本用法
void test01(){
	int a = 10;
	printf("len:%d\n", sizeof(a));
	printf("len:%d\n", sizeof(int));
	printf("len:%d\n", sizeof a);
}
/*
len:4
len:4
len:4
*/

//2. sizeof 结果类型
void test02(){
	unsigned int a = 10;
	if (a - 11 < 0){
		printf("结果小于0\n");
	}
	else{
		printf("结果大于0\n");
	}
	int b = 5;
	if (sizeof(b) - 10 < 0){
		printf("结果小于0\n");
	}
	else{
		printf("结果大于0\n");
	}
}
/*
结果大于0
结果大于0
*/

//3. sizeof 碰到数组
void TestArray(int arr[]){
	printf("sizeof TestArray arr :%d\n",sizeof(arr));
}
void test03(){
	int arr[] = { 100, 200, 300, 400, 500 };
	printf("sizeof array: %d\n",sizeof(arr));

	//数组名在某些情况下等价于指针
	int* pArr = arr;
	printf("sizeof (pArr[2]):%d\n",sizeof(pArr[2]));
	printf("sizeof array: %d\n", sizeof(pArr));

	//数组做函数函数参数，将退化为指针,在函数内部不再返回数组大小
	TestArray(arr);
}
/*
sizeof array: 20
sizeof (pArr[2]):4
sizeof array: 8
sizeof TestArray arr :8
*/
```
### 1.5. 数据类型总结
1.  数据类型本质是固定内存大小的别名，是个模具，C语言规定：**通过数据类型定义变量**；
2.  数据类型大小计算（sizeof）；
3.  可以给已存在的数据类型起别名typedef；
4.  数据类型的封装（void 万能类型）；
## 2. 变量
### 2.1 变量的概念
既能读又能写的内存对象，称为变量；若一旦初始化后不能修改的对象则称为常量。
**变量定义形式：**`类型 标识符1, *标识符2, 标识符3[3]`

### 2.2 变量名的本质
1.  变量名的本质：一段连续内存空间的别名；
2.  程序通过变量来申请和命名内存空间 `int a = 0`；
3.  通过变量名访问内存空间；
4.  不是向变量名读写数据，而是向变量所代表的内存空间中读写数据；

**修改变量的两种方式：**
1. 通过变量名修改
2. 通过地址修改
```cpp
void test1(){

	int a = 10;
    
	//1. 直接修改
	a = 20;
	printf("直接修改,a:%d\n",a);

	//2. 间接修改
	int* p = &a;
	*p = 30;
	printf("间接修改,a:%d\n", a);
}
/*
直接修改,a:20
间接修改,a:30
*/
```
## 3. 程序的内存分区模型
### 3.1 内存分区
#### 3.1.1 运行之前

C程序编译流程：
1.  预处理：宏定义展开、头文件展开、条件编译，这里并**不会检查语法**
2.  编译：检查语法，将预处理后文件编译生成汇编文件
3.  汇编：将汇编文件生成目标文件(二进制文件)
4.  链接：将目标文件链接为可执行程序

当我们编译完成生成可执行文件之后，我们通过在linux下size命令可以查看一个可执行二进制文件基本情况：
![[image/Pasted image 20230418115658.png]]
通过上图可以得知，在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好3段信息，**分别为代码区（text）、数据区（data）和未初始化数据区（bss）** 3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。
1.  代码区
存放 CPU 执行的机器指令。通常代码区是可**共享**的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是**只读**的，使其只读的原因是防止程序意外地修改了它的指t令。另外，代码区还规划了局部变量的相关信息。
2.  全局初始化数据区/静态数据区（data段）
该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量）和常量数据（如字符串常量）。
3.  未初始化数据区（又叫 bss区）
存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。

总体来讲说，程序源代码被编译之后主要分成两种段：**程序指令(代码区)和程序数据（数据区）。代码段属于程序指令，而数据域段和.bss段属于程序数据。**

那为什么把程序的指令和程序数据分开呢？
1.  程序被load到内存中之后，可以将数据和代码分别映射到两个内存区域。由于数据区域对进程来说是可读可写的，而指令区域对程序来讲说是只读的，所以分区之后呢，可以将程序指令区域和数据区域分别设置成可读可写或只读。这样可以防止程序的指令有意或者无意被修改；
2.  当系统中运行着多个同样的程序的时候，这些程序执行的指令都是一样的，所以只需要内存中保存一份程序的指令就可以了，只是每一个程序运行中数据不一样而已，这样可以节省大量的内存。比如说之前的Windows Internet Explorer 7.0运行起来之后，它需要占用112 844KB的内存，它的私有部分数据有大概15 944KB，也就是说有96 900KB空间是共享的，如果程序中运行了几百个这样的进程，可以想象共享的方法可以节省大量的内存。
#### 3.1.2 运行之后
**程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变。** 然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。
1.  代码区（text segment）
加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。
2.  未初始化数据区（BSS）
加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。
3.  全局初始化数据区/静态数据区（data segment）
加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。
4.  栈区（stack）
栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。
5.  堆区（heap）
堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。

<font color="#ff0000"><b>建立正确程序运行内存布局图是学好C的关键</b></font>

|类型|作用域|生命周期|存储位置|
|------|-----|-----|-----|
|auto变量|一对{}内|当前函数|栈区|
|static局部变量|一对{}内|整个程序运行期|初始化在data段，未初始化在BSS段|
|extern变量|整个程序|整个程序运行期|初始化在data段，未初始化在BSS段|
|static全局变量|当前文件|整个程序运行期|初始化在data段，未初始化在BSS段|
|extern函数|整个程序|整个程序运行期|代码区|
|static函数|当前文件|整个程序运行期|代码区|
|register变量|一对{}内|当前函数|运行时存储在CPU寄存器|
|字符串常量|当前文件|整个程序运行期|data段|
### 3.2 分区模型
#### 3.2.1 栈区
由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。
```cpp
char* func(){
	char p[] = "hello world!"; 
	printf("%s\n", p);
	return p;
}
void test(){
	char* p = NULL;
	p = func();  
	printf("%s\n",p); //在栈区存储 乱码
}
/*
hello world!
烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫
*/
```
#### 3.2.2 堆区
由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用`malloc()`或者`new()`进行堆的申请。
```cpp
char* func(){
	char* str = malloc(100);
	strcpy(str, "hello world!");
	printf("%s\n",str);
	return str;
}
void test01(){
	char* p = NULL;
	p = func();
	printf("%s\n",p);
}
/*
hello world!
hello world!
*/

void allocateSpace(char* p){
	p = malloc(100);
	strcpy(p, "hello world!");
	printf("%s\n", p);
}
void test02(){
	
	char* p = NULL;
	// 函数并未对p做出修改，因为函数为值传递并非地址传递
	// 若需要修改p的值需要使用二级指针
	allocateSpace(p); 
	printf("%s\n", p);
}
/*
hello world!
(null)
*/
```
![[image/Pasted image 20230418141235.png]]
#### 3.2.3 堆分配内存API
##### calloc()
```cpp
#include <stdlib.h>
void * calloc(size_t nmemb, size_t size);
```
**功能：**
在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存置0。

**参数：**
-   nmemb：所需内存单元数量
-   size：每个内存单元的大小（单位：字节）

**返回值：**
-   成功：分配空间的起始地址
-   失败：NULL
##### realloc()
```cpp
#include <stdlib.h>
void *realloc(void *ptr, size_t size);
```
**功能：**
重新分配用malloc或者calloc函数在堆中分配内存空间的大小。

**注意：**
realloc不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，**同时释放旧内存**。

**参数：**
-   ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致
-   size：为重新分配内存的大小**,**单位：字节

**返回值：**
-   成功：新分配的堆内存地址
-   失败：NULL
##### 示例
```cpp
void test01(){
	
	// 申请内存
	int* p1 = calloc(10, sizeof(int));
	if (p1 == NULL) {
		return;
	}
	// 赋值
	for (int i = 0; i < 10; i++) {
		p1[i] = i + 1;
	}

	// 输出
	for (int i = 0; i < 10; i++) {
		printf("%d ", p1[i]);
	}
	printf("\n");

	// 重新分配内存 reallo会自动释放p1 
	int* p2 = realloc(p1, 15 * sizeof(int));
	if (p2 == NULL) {
		return;
	}

	//重新赋值
	for (int i = 0; i < 15; i++) {
		p2[i] = i + 100;
	}

	//再次打印
	for (int i = 0; i < 15; i++) {
		printf("%d ", p2[i]);
	}
	printf("\n");

	// 释放p2
	free(p2);
}
/*
1 2 3 4 5 6 7 8 9 10
100 101 102 103 104 105 106 107 108 109 110 111 112 113 114
*/
```
#### 3.2.4 全局/静态区
全局静态区内的变量在编译阶段已经分配好内存空间并初始化。这块内存在程序运行期间一直存在,它主要存储**全局变量**、**静态变量**和**常量**。

<font color="#ff0000"><b>注意：</b></font>
1.  **这里不区分初始化和未初始化的数据区**，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。
2.  全局静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。
3.  字符串常量存储在全局/静态存储区的常量区。
4. <span style="background:#fff88f">不要去修改字符串常量！</span>

```cpp
int v1 = 10;//全局/静态区
const int v2 = 20; //常量，一旦初始化，不可修改
static int v3 = 20; //全局/静态区
char *p1; //全局/静态区，编译器默认初始化为NULL

void test(){
	static int v4 = 20; //全局/静态区
}

char* func(){
	static char arr[] = "hello world!"; //在静态区存储 可读可写
	arr[2] = 'c';
	char* p = "hello world!"; //全局/静态区-字符串常量区 
	//p[2] = 'c'; //只读，不可修改 
	printf("%d\n",arr);
	printf("%d\n",p);
	printf("%s\n", arr);
	return p;
}
void test(){
	char* p = func();
	printf("%s\n",p);
}
/*
1068679248
1068669976
heclo world!
hello world!
*/
```

**字符串常量是否可修改？字符串常量优化：**
ANSI C中规定：修改字符串常量，结果是未定义的。
ANSI C并没有规定编译器的实现者对字符串的处理，例如：
1.  有些编译器可修改字符串常量，有些编译器则不可修改字符串常量。
2.  有些编译器把多个相同的字符串常量看成一个（这种优化可能出现在字符串常量中，节省空间），有些则不进行此优化。如果进行优化，则可能导致修改一个字符串常量导致另外的字符串常量也发生变化，结果不可知。
**字符串常量地址是否相同？**
1.  tc2.0，同文件字符串常量地址不同。
2.  Vs2013,字符串常量地址同文件和不同文件都相同。
3.  Dev c++、QT同文件相同，不同文件不同。

在理解C/C++内存分区时，常会碰到如下术语：数据区，堆，栈，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等等。在这里，尝试捋清楚以上分区的关系。
1. **数据区包括**：堆，栈，全局/静态存储区。  
2. **全局/静态存储区包括**：常量区，全局区、静态区。  
3. **常量区包括**：字符串常量区、常变量区。  
4. **代码区**：存放程序编译后的二进制代码，不可寻址区。

#### 3.2.5 全局/静态变量的区别
**全局变量、局部变量、静态全局变量、静态局部变量的区别**
C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：**全局作用域**，**局部作用域**，**语句作用域**，**类作用域**，**命名空间作用域和文件作用域**。

**从作用域看：**
1. 全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。
2. 静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
3. 局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
4. 静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

**从分配内存空间看：**
1. 全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。
2. 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
3. 静态变量会被放在程序的静态数据存储区（数据段）(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。
4. 变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。

<span style="background:#fff88f">从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。</span>

**Tips:**
-   A、若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；
-   B、若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；
-   C、设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；
-   D、如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带“内部存储器”功能的的函数)
-   E、函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。


**static 全局变量**：改变作用范围，不改变存储位置
**static 局部变量**：改变存储位置，不改变作用范围

**静态函数** ：在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。

如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数也称为内部函数。定义一个内部函数，只需在函数类型前再加一个“static”关键字即可。
### 3.3 函数调用模型
#### 3.3.1 函数调用流程
栈(stack)是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能见到的所有计算机的语言。在解释为什么栈如此重要之前，我们先了解一下传统的栈的定义：

在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将压入栈中的数据弹出(出栈，pop),但是栈容器必须遵循一条规则：先入栈的数据最后出栈(First In Last Out,FILO).

在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。

栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：

1.  函数的返回地址；
2.  函数的参数；
3.  临时变量；
4.  保存的上下文：包括在函数调用前后需要保持不变的寄存器。
![[image/Pasted image 20230418154951.png| 600]]
#### 3.3.2 调用惯例
假设函数调用方在传递参数的时候先压入a参数，再压入b参数，而被调用函数则认为先压入的是b,后压入的是a,那么被调用函数在使用a,b值时候，就会颠倒。因此，**函数的调用方和被调用方对于函数是如何调用的必须有一个明确的约定，只有双方都遵循同样的约定，函数才能够被正确的调用，这样的约定被称为”调用惯例(Calling Convention)”**.

一个调用惯例一般包含以下几个方面：
1.  **函数参数的传递顺序和方式**
函数的传递有很多种方式，最常见的是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：从左向右，还是从右向左。有些调用惯例还允许使用寄存器传递参数，以提高性能。
2.  **栈的维护方式**
在函数将参数压入栈中之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。

为了在链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。在c语言里，存在着多个调用惯例，而默认的是cdecl.任何一个没有显示指定调用惯例的函数都是默认是cdecl惯例。比如我们上面对于func函数的声明，它的完整写法应该是：
`int _cdecl func(int a,int b);`
**注意: `_cdecl`不是标准的关键字，在不同的编译器里可能有不同的写法，例如gcc里就不存在`_cdecl`这样的关键字，而是使用`__attribute__((cdecl))`.**

|调用惯例|出栈方|参数传递|名字修饰|
|----|----|----|---|
|cdecl|函数调用方|从右至左参数入栈|下划线+函数名|
|stdcall|函数本身|从右至左参数入栈|下划线+函数名+@+参数字节数|
|fastcall|函数本身|前两个参数由寄存器传递，其余参数通过堆栈传递。|@+函数名+@+参数的字节数|
|pascal|函数本身|从左至右参数入栈|较为复杂，参见相关文档|
#### 3.3.2 函数变量传递分析
![[image/20230418160650.png|300]]![[image/20230418160657.png|300]]
![[image/Pasted image 20230418161135.png|300]]![[image/Pasted image 20230418161142.png|300]]
![[image/Pasted image 20230418161158.png|300]]
### ? 3.4 栈的生长方向和内存存放方向
![[image/Pasted image 20230418161346.png]]
![[image/Pasted image 20230418161359.png]]
```cpp
//1. 栈的生长方向
void test01() {

	int a = 10;
	int b = 20;
	int c = 30;
	int d = 40;

	printf("a = %u\n", &a);
	printf("b = %u\n", &b);
	printf("c = %u\n", &c);
	printf("d = %u\n", &d);

	//a的地址大于b的地址，故而生长方向向下
}
/*
a = 3672110276
b = 3672110308
c = 3672110340
d = 3672110372
*/

//2. 内存生长方向(小端模式)
void test02() {

	//高位字节 -> 地位字节
	int num = 0xaabbccdd;
	unsigned char* p = &num;

	//从首地址开始的第一个字节
	printf("%x\n", *p);
	printf("%x\n", *(p + 1));
	printf("%x\n", *(p + 2));
	printf("%x\n", *(p + 3));
}
/*
dd
cc
bb
aa
*/
```